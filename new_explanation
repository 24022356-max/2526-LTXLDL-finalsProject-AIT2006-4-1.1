# ============= BASELINE FORECAST ============#
print("\nCalculating Baseline...")
last_week = data['trips'].iloc[-7:]
baseline_future = np.tile(last_week.values, (FORECAST_DAYS // 7) + 1)[:FORECAST_DAYS]

Base_line:
kỹ thuật này sử dụng những pattern trong quá khứ và copy chúng vào tương lai để dự đoán kết quả 
đây chỉ là giả định nhé

last_week = data['trips].iloc[-7:]
function này dùng để lấy giữ liệu(số lượng trips đi trong 7 ngày cuối cùng của kpi).
vd: kiểu lấy từ thứ 2 ở tuần cuối cùng có 25000 trips thì thứ 2 ở tuần sau đó cũng có 25000 trips
ex:
# Lấy 7 ngày cuối cùng trong data (25/12 - 31/12/2019)
last_week = df['trips'].iloc[-7:]  # [28000, 29000, 27500, 26000, 25000, 24000, 26500]

qua đấy thì function baseline_future
copy lại cái pattern của số lượng trips này
# Lặp lại pattern này đủ 30 lần
# Kết quả: [28000, 29000, 27500, 26000, 25000, 24000, 26500, 28000, 29000, ..., 30 giá trị]

nchung đây chỉ là t lấy giá trị của trips tuần trước đấy r copy lại sang tuần sau để forecast


# ========== LINEAR REGRESSION FORECAST =======#
print("\nCalculating Linear Regression...")
features = pd.DataFrame(index=data.index)
features['dayofweek'] = features.index.dayofweek.astype('int8')
features['month'] = features.index.month.astype('int8')
features['lag_7'] = data['trips'].shift(7)
features['lag_30'] = data['trips'].shift(30)
features['rolling_7'] = data['trips'].shift(1).rolling(7).mean()

các feature ở đây là nằm trong mô hình để dự báo:


1. dayofweek -  taxi có pattern rõ ràng:
vào các ngày bình thường taxi sẽ đi nhiều hơn vd thứ 2- thứ 5
vào các ngày cuối tuần thì sẽ ít đi hẳn vậy nên cần feature này để đưa vào mô hình dự đoán
2. month - tương tự như dayofweek thì có các tháng có nhiều trips hơn vì ngày lễ kiểu tháng 12 và ít trips hơn vào mùa hè
3. các giá trị lag_7 , lag_30:
đây giống kiểu baseline là đưa ra dự đoán cho các ngày trong tuần trong tương lai hoặc tháng trong tương lai, với
cái này thì lag_7 sẽ bắt chu kỳ các ngày trong tuần để dự đoán trend trong các tuần sẽ giống nhau và đưa ra giá trị peak(max trips)
tương tự với tháng lag_30 

vd:
Khi ở 01/01/2020, lag_7 sẽ chứa giá trị của 25/12/2019(shift(7))
Thứ 4 tuần trước ≈ Thứ 4 tuần này
Bắt chu kỳ 7 ngày (weekly seasonality).

4.rolling_7 là tính giá trị trung bình của 7 ngày thôi,
qua giá trị trung bình thì nếu có 1 ngày mà trend nó thay đổi quá bất ngờ thì sẽ chèn giá trị trung bình vào để dự đoán
vd kiểu có 1 ngày dính bão thì số lượng trips sẽ giảm đốt ngột nên đây là cách để làm mượt

5. Tổng kết:
các bước ở trên chỉ là các bước chuẩn bị dữ liệu để train model

***Dưới đây là các bước train model linear regression
X_train = features.dropna()
y_train = data.loc[X_train.index, 'trips']

###
shift(k) tạo k hàng NaN đầu tiên → dropna() xóa hàng chưa đủ feature
y_train phải cùng index với X_train → mỗi hàng có đầy đủ X và y
###


lr_model = LinearRegression(n_jobs=-1)
lr_model.fit(X_train, y_train)

###cái này thì tại vì t ko biết viết chuẩn model LinearRegression nên dùng model có sẵn của scikit learn
và thêm vào các parameters
# ============== CREATE FUTURE FEATURES =============#
future_dates = pd.date_range(data.index[-1] + pd.Timedelta(days=1), periods=FORECAST_DAYS)
future_features = pd.DataFrame(index=future_dates)
future_features['dayofweek'] = future_features.index.dayofweek.astype('int8')
future_features['month'] = future_features.index.month.astype('int8')

cái ở trên là các dữ liệu ở trong quá khứ còn ở đây là dữ liệu dự đoán( đây chỉ là tạo màng kèm index)
** t dùng astype int8 để giảm độ nặng lên ram mặc dù không cần thiết lắm



# FIX LENGTH MISMATCH - Tile lag patterns(ở đây là t đang sửa khác n dimension để dùng được với nhau thôi)
lag_7_values = data['trips'].iloc[-7:].values
future_features['lag_7'] = np.tile(lag_7_values, (FORECAST_DAYS // 7) + 1)[:FORECAST_DAYS]

lag_30_values = data['trips'].iloc[-30:].values
future_features['lag_30'] = np.tile(lag_30_values, (FORECAST_DAYS // 30) + 1)[:FORECAST_DAYS]

# Rolling mean is a single value, pandas will broadcast it
future_features['rolling_7'] = data['trips'].iloc[-7:].mean()

# Predict
đây là sự dụng function của model LinearREgression có sẵn để check kết quả dự đoán

#lr_future là Dataframe 30 hàng hiển thị kết quả của 30 ngày tới
#lr_model.predict(...) trả về mảng numpy 30 phần tử KIỂU float64
→ Ví dụ: [26123.4, 24888.7, -1273.2, 30000.8, ...]
lr_future = lr_model.predict(future_features)

lr_future = np.maximum(lr_future, 0).astype('int32')
vì LR có thể tạo ra số âm nên cái này để cắt phần âm


# =============== ARIMA FORECAST =============#
print("\nTraining ARIMA...")
arima_train = data['trips'].iloc[-200:]
arima_model = SARIMAX(arima_train, order=(2, 1, 2), low_memory=True)
arima_fitted = arima_model.fit(disp=False, low_memory=True)
arima_future = arima_fitted.forecast(steps=FORECAST_DAYS)
arima_future = np.maximum(arima_future, 0).astype('int32')

cái arima thì t chatgpt nên chắc nhờ nó giải thích luôn
1. Mục tiêu
Dự báo 30 ngày tới cho trips (số chuyến xe) bằng ARIMA(2,1,2) – nhanh, nhẹ, không cần external feature.
2. Chuẩn bị dữ liệu
200 điểm đủ bắt trend + seasonality ngắn mà không overfit toàn bộ 10 năm.
iloc[-200:] → chỉ lấy cuối, vì gần đây mang thông tin mới nhất.
3. Chọn mô hình
| Ký hiệu           | Ý nghĩa thực tế                                                | Giá trị chọn | Lý do                                   |
| ----------------- | -------------------------------------------------------------- | ------------ | --------------------------------------- |
| **p=2**           | Số **AR terms** – dùng **2 giá trị quá khứ** để dự báo         | 2            | Đủ bắt **momentum ngắn** mà không nhiễu |
| **d=1**           | Số **lần differencing** (`today − yesterday`)                  | 1            | Làm **stationary** – trend ổn định      |
| **q=2**           | Số **MA terms** – dùng **2 lỗi dự báo gần nhất** để điều chỉnh | 2            | **Khử noise** nhanh                     |
| `low_memory=True` | Giảm RAM khi series dài                                        | –            | **An toàn** cho notebook                |
4.fitted = model.fit(disp=False, low_memory=True).
disp=False → không in log lên terminal (sạch output).
Trả về object chứa coefficients AR & MA, residuals, AIC/BIC, v.v.

5. Tạo forecast
forecast = fitted.forecast(steps=30)
steps=30 → ARIMA tự động:
Differencing nếu cần (đã học d=1)
Dùng AR(p) & MA(q) để tính từng bước
Cập nhật lỗi và đẩy về giá trị gốc (undo differencing)
Output: mảng numpy 30 phần tử float (có thể âm)

6. làm sạch kết quả 
forecast = np.maximum(forecast, 0).astype('int32')



